<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>학급 편성 도우미 Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- SheetJS for Excel Export & Import -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body { font-family: 'Malgun Gothic', 'Apple SD Gothic Neo', sans-serif; background-color: #f8fafc; }
        .student-chip {
            display: inline-flex; align-items: center; gap: 4px;
            padding: 3px 10px; margin: 3px; border-radius: 999px;
            font-size: 0.85rem; border: 1px solid transparent;
            cursor: pointer; transition: transform 0.1s;
        }
        .student-chip:hover { transform: scale(1.05); z-index: 5; }
        .chip-male { background-color: #e0f2fe; color: #0369a1; border-color: #bae6fd; }
        .chip-female { background-color: #fce7f3; color: #be185d; border-color: #fbcfe8; }
        .fixed-pin { color: #dc2626; font-size: 0.7rem; }
        .move-badge { 
            background-color: #ef4444; color: white; 
            font-size: 0.65rem; padding: 1px 4px; border-radius: 4px; 
            font-weight: bold; margin-right: 4px;
        }
        textarea::-webkit-scrollbar { width: 8px; }
        textarea::-webkit-scrollbar-track { background: #f1f1f1; }
        textarea::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .highlight-target { ring: 2px solid #eab308; transform: scale(1.1); z-index: 10; font-weight: bold; }
        .highlight-friend { ring: 2px solid #22c55e; transform: scale(1.05); }
        .highlight-enemy { ring: 2px solid #ef4444; opacity: 0.8; }
        .dimmed { opacity: 0.3; filter: grayscale(100%); }
    </style>
</head>
<body class="text-slate-800 h-screen flex flex-col overflow-hidden">

    <!-- Top Nav -->
    <nav class="bg-white border-b border-slate-200 px-4 py-3 flex flex-wrap justify-between items-center shadow-sm z-10 gap-2">
        <div class="flex items-center gap-3">
            <div class="bg-indigo-600 text-white w-8 h-8 rounded-lg flex items-center justify-center font-bold shrink-0">
                <i class="fas fa-file-excel"></i>
            </div>
            <h1 class="text-lg md:text-xl font-bold bg-gradient-to-r from-indigo-700 to-purple-600 bg-clip-text text-transparent whitespace-nowrap">
                학급 편성 도우미 Pro
            </h1>
        </div>
        
        <div class="flex items-center gap-2 md:gap-4 overflow-x-auto no-scrollbar">
            <!-- Class Count -->
            <div class="flex items-center gap-2 bg-slate-100 px-3 py-1.5 rounded-lg border border-slate-200 shrink-0">
                <span class="text-xs font-bold text-slate-500">학급수</span>
                <input type="number" id="classCount" value="10" min="2" max="20" class="w-8 bg-transparent text-center font-bold text-indigo-700 focus:outline-none border-b border-slate-300">
            </div>

            <!-- Size Limit -->
            <div class="flex items-center gap-2 bg-slate-100 px-3 py-1.5 rounded-lg border border-slate-200 shrink-0">
                <span class="text-xs font-bold text-slate-500">인원</span>
                <div class="flex items-center gap-1">
                    <input type="number" id="minPerClass" value="31" min="1" max="50" class="w-8 bg-transparent text-center font-bold text-slate-700 focus:outline-none border-b border-slate-300 placeholder-slate-300">
                    <span class="text-slate-400">~</span>
                    <input type="number" id="maxPerClass" value="32" min="1" max="50" class="w-8 bg-transparent text-center font-bold text-red-600 focus:outline-none border-b border-red-200 placeholder-slate-300">
                </div>
            </div>

            <!-- Score Tolerance -->
            <div class="flex items-center gap-2 bg-yellow-50 px-3 py-1.5 rounded-lg border border-yellow-200 shrink-0" title="반 평균 점수의 격차가 이 값 이내라면 원래 반을 유지합니다.">
                <span class="text-xs font-bold text-yellow-700">평균격차허용</span>
                <input type="number" id="scoreTolerance" value="50" step="0.5" min="0" max="100" class="w-10 bg-transparent text-center font-bold text-yellow-800 focus:outline-none border-b border-yellow-400">
                <span class="text-xs text-yellow-600">점</span>
            </div>

            <!-- Random Shuffle Toggle -->
            <div class="flex items-center gap-2 bg-purple-50 px-3 py-1.5 rounded-lg border border-purple-200 shrink-0" title="체크 시 실행할 때마다 결과가 조금씩 달라집니다.">
                <input type="checkbox" id="useRandom" class="w-4 h-4 text-purple-600 rounded focus:ring-purple-500 border-gray-300 cursor-pointer">
                <label for="useRandom" class="text-xs font-bold text-purple-700 cursor-pointer select-none">무작위 섞기</label>
            </div>

            <div class="flex gap-2">
                <button onclick="runAnalysis()" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg font-bold shadow-md transition flex items-center gap-2 shrink-0 text-sm whitespace-nowrap">
                    <i class="fas fa-play"></i> <span class="hidden md:inline">실행</span>
                </button>
                <button onclick="exportToExcel()" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg font-bold shadow-md transition flex items-center gap-2 shrink-0 text-sm whitespace-nowrap">
                    <i class="fas fa-download"></i> <span class="hidden md:inline">엑셀 저장</span>
                </button>
            </div>
        </div>
    </nav>

    <!-- Main Layout -->
    <div class="flex-grow flex flex-col lg:flex-row overflow-hidden">
        
        <!-- Sidebar -->
        <aside class="w-full lg:w-[400px] bg-white border-r border-slate-200 flex flex-col overflow-y-auto z-0 shadow-lg shrink-0">
            <div class="p-4 space-y-5">
                
                <!-- Excel Data Management Buttons -->
                <div class="flex gap-2 mb-2">
                    <button onclick="downloadTemplate()" class="flex-1 bg-slate-100 hover:bg-slate-200 text-slate-700 py-2 rounded-lg text-xs font-bold border border-slate-300 transition flex items-center justify-center gap-1">
                        <i class="fas fa-file-download text-blue-600"></i> 양식 다운로드
                    </button>
                    <label class="flex-1 bg-blue-50 hover:bg-blue-100 text-blue-700 py-2 rounded-lg text-xs font-bold border border-blue-200 transition flex items-center justify-center gap-1 cursor-pointer">
                        <i class="fas fa-folder-open"></i> 데이터 불러오기
                        <input type="file" id="uploadInput" accept=".xlsx, .xls" class="hidden" onchange="importData(this)">
                    </label>
                </div>

                <div class="border-t border-slate-100 my-1"></div>

                <!-- 1. Master Data -->
                <div class="space-y-2">
                    <div class="flex justify-between items-center">
                        <label class="text-sm font-bold text-slate-800 flex items-center gap-2">
                            <span class="bg-slate-800 text-white w-5 h-5 rounded-full flex items-center justify-center text-xs">1</span>
                            전체 명단
                        </label>
                        <span class="text-[0.6rem] text-slate-400 font-bold bg-slate-100 px-2 py-0.5 rounded">진급반 / 현재반 / 이름 / 성별 / 점수</span>
                    </div>
                    <textarea id="inputMaster" class="w-full h-40 p-3 text-xs border border-slate-300 rounded-lg focus:outline-none focus:border-indigo-500 transition leading-relaxed" 
                        placeholder="예시:&#13;&#10;1 / 3 / 홍길동 / 남 / 112.5&#13;&#10;1 / 3 / 이영희 / 여 / 205.1&#13;&#10;2 / 4 / 김철수 / 남 / 180.0"></textarea>
                </div>

                <!-- 2. Fixed Assignment -->
                <div class="space-y-2">
                    <div class="flex justify-between items-center">
                        <label class="text-sm font-bold text-indigo-700 flex items-center gap-2">
                            <span class="bg-indigo-100 text-indigo-700 w-5 h-5 rounded-full flex items-center justify-center text-xs">2</span>
                            반 고정 (강제)
                        </label>
                        <span class="text-xs text-slate-400">이름 / 반</span>
                    </div>
                    <textarea id="inputFixed" class="w-full h-20 p-3 text-xs border border-slate-300 rounded-lg focus:outline-none focus:border-indigo-500 transition" 
                        placeholder="예: 최일반 / 1"></textarea>
                </div>

                <div class="border-t border-slate-100 my-1"></div>

                <div class="space-y-4">
                    <h3 class="text-xs font-bold text-slate-400 uppercase tracking-wider">관계 설정</h3>
                    <div class="grid grid-cols-2 gap-2">
                        <div class="space-y-1">
                            <label class="text-xs font-bold text-green-700 flex items-center gap-1"><i class="fas fa-link"></i> 단짝</label>
                            <textarea id="inputTogether" class="w-full h-24 p-2 text-xs border border-slate-300 rounded-lg focus:outline-none focus:border-green-500 transition resize-none" placeholder="김철수, 이훈이"></textarea>
                        </div>
                        <div class="space-y-1">
                            <label class="text-xs font-bold text-red-600 flex items-center gap-1"><i class="fas fa-bomb"></i> 분리</label>
                            <textarea id="inputSeparate" class="w-full h-24 p-2 text-xs border border-slate-300 rounded-lg focus:outline-none focus:border-red-500 transition resize-none" placeholder="홍길동, 임꺽정"></textarea>
                        </div>
                    </div>
                    <div class="space-y-1">
                        <div class="flex justify-between items-center">
                            <label class="text-xs font-bold text-orange-600 flex items-center gap-1"><i class="fas fa-shield-alt"></i> 피하기</label>
                            <div class="flex items-center gap-1">
                                <input type="checkbox" id="avoidSplitRight" class="w-3 h-3 text-orange-600 rounded border-gray-300 focus:ring-orange-500" checked>
                                <label for="avoidSplitRight" class="text-[0.6rem] text-slate-500 font-bold cursor-pointer select-none" title="// 오른쪽 학생들끼리도 가급적 분리합니다">// 이후 학생들 분리</label>
                            </div>
                        </div>
                        <textarea id="inputAvoid" class="w-full h-16 p-2 text-xs border border-slate-300 rounded-lg focus:outline-none focus:border-orange-500 transition resize-none" placeholder="철수, 영희 // 민수, 길동"></textarea>
                    </div>
                </div>

                <button onclick="clearAll()" class="w-full py-2 text-xs font-bold text-slate-400 hover:text-red-500 hover:bg-red-50 rounded transition border border-dashed border-slate-300 hover:border-red-300">
                    <i class="fas fa-trash-alt mr-1"></i> 입력 초기화
                </button>
            </div>
        </aside>

        <!-- Main Results -->
        <main class="flex-grow bg-slate-50 flex flex-col overflow-hidden relative">
            
            <div id="globalStats" class="bg-white border-b border-slate-200 px-6 py-3 flex gap-6 text-sm overflow-x-auto whitespace-nowrap hidden shadow-[0_4px_6px_-1px_rgba(0,0,0,0.05)] z-10"></div>
            
            <div id="statusToast" class="hidden absolute top-4 left-1/2 transform -translate-x-1/2 z-50 px-6 py-3 rounded-full shadow-lg font-bold text-sm transition-all duration-300 border border-white/20 backdrop-blur-sm"></div>

            <div id="resultContainer" class="flex-grow p-6 overflow-y-auto">
                <div class="h-full flex flex-col items-center justify-center text-slate-400">
                    <div class="bg-white p-8 rounded-full shadow-sm mb-4">
                        <i class="fas fa-file-excel text-5xl text-indigo-200"></i>
                    </div>
                    <h3 class="text-lg font-bold text-slate-600">준비 완료</h3>
                    <p class="text-sm mt-2 max-w-md text-center text-slate-500">
                        <strong>[양식 다운로드]</strong>를 눌러 엑셀 템플릿을 받고,<br>
                        내용을 채운 뒤 <strong>[데이터 불러오기]</strong>로 업로드하세요.<br>
                        개인정보는 서버에 저장되지 않습니다.
                    </p>
                </div>
            </div>
            
        </main>
    </div>

    <!-- Core Logic -->
    <script>
        class Student {
            constructor(draftClass, currentClass, name, gender, score) {
                this.draftClass = parseInt(draftClass); // 진급예정반
                this.currentClass = parseInt(currentClass) || 0; // 현재반
                this.name = name.trim();
                this.gender = gender.trim() === '여' || gender.toUpperCase() === 'F' ? 'F' : 'M';
                this.score = parseFloat(score) || 0;
                this.fixedClass = null;
                this.teamId = null;
                this.finalClass = null;
            }
        }

        class Team {
            constructor(id) {
                this.id = id;
                this.members = [];
                this.fixedClass = null;
                this.draftClass = null; // Changed from originalClass
                this.constraints = new Set(); 
                this.softConstraints = new Set();
            }
            get totalScore() { return this.members.reduce((sum, s) => sum + s.score, 0); }
            get count() { return this.members.length; }
            get genderCount() {
                return this.members.reduce((acc, s) => {
                    s.gender === 'M' ? acc.M++ : acc.F++;
                    return acc;
                }, { M: 0, F: 0 });
            }
            addMember(student) { this.members.push(student); student.teamId = this.id; }
            resolveDraftClass() {
                // Determine preferred draft class based on majority/first valid
                const classes = this.members.map(m => m.draftClass).filter(c => !isNaN(c) && c > 0);
                this.draftClass = classes.length > 0 ? classes[0] : null; 
            }
        }

        let allStudents = new Map(); 
        let allTeams = [];
        let finalClasses = []; 
        
        function showStatus(msg, type = 'info') {
            const el = document.getElementById('statusToast');
            el.innerHTML = type === 'error' ? `<i class="fas fa-exclamation-triangle mr-2"></i>${msg}` : `<i class="fas fa-check-circle mr-2"></i>${msg}`;
            el.className = `absolute top-4 left-1/2 transform -translate-x-1/2 z-50 px-6 py-3 rounded-full shadow-lg font-bold text-sm transition-all duration-300 ${type === 'error' ? 'bg-red-600 text-white' : 'bg-green-600 text-white'}`;
            el.classList.remove('hidden');
            setTimeout(() => el.classList.add('hidden'), 5000);
        }

        function parseNames(str) {
            return str.split(/[\t,]+/).map(s => s.trim()).filter(s => s.length > 0);
        }

        function clearAll() {
            if(!confirm('모든 입력 데이터를 삭제하시겠습니까?')) return;
            document.querySelectorAll('textarea').forEach(el => el.value = '');
            document.getElementById('resultContainer').innerHTML = '';
            document.getElementById('globalStats').classList.add('hidden');
        }

        // --- Template Download ---
        function downloadTemplate() {
            const wb = XLSX.utils.book_new();

            // Sheet 1: Existing Roster
            const ws1Data = [
                ['진급예정반', '현재반', '이름', '성별', '점수'], 
                ['1', '3', '홍길동', '남', '85'],
                ['1', '3', '이영희', '여', '90'],
                ['2', '4', '김철수', '남', '88']
            ];
            const ws1 = XLSX.utils.aoa_to_sheet(ws1Data);
            XLSX.utils.book_append_sheet(wb, ws1, "기존명단");

            // Sheet 2: Fixed Class
            const ws2Data = [
                ['이름', '고정반'],
                ['최일반', '1'],
                ['김이반', '2']
            ];
            const ws2 = XLSX.utils.aoa_to_sheet(ws2Data);
            XLSX.utils.book_append_sheet(wb, ws2, "반고정");

            // Sheet 3: Together
            const ws3Data = [
                ['설명(선택)', '학생1', '학생2', '학생3', '...'],
                ['같은반 희망', '김철수', '이훈이', ''],
                ['삼총사', '박영희', '최미나', '정수정']
            ];
            const ws3 = XLSX.utils.aoa_to_sheet(ws3Data);
            XLSX.utils.book_append_sheet(wb, ws3, "단짝");

            // Sheet 4: Separate
            const ws4Data = [
                ['설명(선택)', '학생1', '학생2', '학생3', '...'],
                ['싸움', '홍길동', '임꺽정', ''],
                ['소란', '장길산', '전우치', '']
            ];
            const ws4 = XLSX.utils.aoa_to_sheet(ws4Data);
            XLSX.utils.book_append_sheet(wb, ws4, "분리");

            // Sheet 5: Avoid
            const ws5Data = [
                ['설명(선택)', '학생...', '구분자(//)', '학생...', '...'],
                ['학폭위', '나피해', '//', '김일진', '박이진'],
                ['관계', 'A', 'B', '//', 'C', 'D']
            ];
            const ws5 = XLSX.utils.aoa_to_sheet(ws5Data);
            XLSX.utils.book_append_sheet(wb, ws5, "피하기");

            XLSX.writeFile(wb, "반편성_입력양식.xlsx");
        }

        // --- Data Import ---
        function importData(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, {type: 'array'});

                // 1. 기존명단 (Sheet 1) - Updated to 5 columns
                if (workbook.SheetNames.length > 0) {
                    const ws = workbook.Sheets[workbook.SheetNames[0]];
                    const json = XLSX.utils.sheet_to_json(ws, {header: 1});
                    let text = "";
                    let startRow = 1; 
                    
                    for (let i = startRow; i < json.length; i++) {
                        const row = json[i];
                        if (row.length >= 3) { // Needs at least Class, Current Class, Name
                            const nc = row[0] || ""; // New Class (Draft)
                            const oc = row[1] || ""; // Old/Current Class
                            const n = row[2] || "";
                            const g = row[3] || "남";
                            const s = row[4] || "0";
                            text += `${nc} / ${oc} / ${n} / ${g} / ${s}\n`;
                        }
                    }
                    document.getElementById('inputMaster').value = text;
                }

                // ... Other sheets logic remains same ...
                // 2. 반고정
                if (workbook.SheetNames.length > 1) {
                    const ws = workbook.Sheets[workbook.SheetNames[1]];
                    const json = XLSX.utils.sheet_to_json(ws, {header: 1});
                    let text = "";
                    for (let i = 1; i < json.length; i++) {
                        const row = json[i];
                        if (row.length >= 2 && row[0]) {
                            text += `${row[0]} / ${row[1]}\n`;
                        }
                    }
                    document.getElementById('inputFixed').value = text;
                }

                // 3. 단짝
                if (workbook.SheetNames.length > 2) {
                    const ws = workbook.Sheets[workbook.SheetNames[2]];
                    const json = XLSX.utils.sheet_to_json(ws, {header: 1});
                    let text = "";
                    for (let i = 1; i < json.length; i++) {
                        const row = json[i];
                        const names = row.slice(1).map(cell => cell == null ? "" : String(cell).trim()).filter(s => s !== "");
                        if (names.length > 0) text += names.join(', ') + '\n';
                    }
                    document.getElementById('inputTogether').value = text;
                }

                // 4. 분리
                if (workbook.SheetNames.length > 3) {
                    const ws = workbook.Sheets[workbook.SheetNames[3]];
                    const json = XLSX.utils.sheet_to_json(ws, {header: 1});
                    let text = "";
                    for (let i = 1; i < json.length; i++) {
                        const row = json[i];
                        const names = row.slice(1).map(cell => cell == null ? "" : String(cell).trim()).filter(s => s !== "");
                        if (names.length > 0) text += names.join(', ') + '\n';
                    }
                    document.getElementById('inputSeparate').value = text;
                }

                // 5. 피하기
                if (workbook.SheetNames.length > 4) {
                    const ws = workbook.Sheets[workbook.SheetNames[4]];
                    const json = XLSX.utils.sheet_to_json(ws, {header: 1});
                    let text = "";
                    for (let i = 1; i < json.length; i++) {
                        let row = json[i];
                        if (!row || row.length < 2) continue;
                        const cells = row.slice(1).map(c => (c != null) ? String(c).trim() : "").filter(s => s !== "");
                        if (cells.length === 0) continue;
                        const joined = cells.join(', '); 
                        if (joined.includes('//')) {
                            text += joined + '\n';
                        } else if (cells.length >= 2) {
                            const sepIndex = cells.indexOf('//');
                            if(sepIndex !== -1) {
                                const left = cells.slice(0, sepIndex).join(', ');
                                const right = cells.slice(sepIndex + 1).join(', ');
                                text += `${left} // ${right}\n`;
                            } else {
                                text += `${cells[0]} // ${cells.slice(1).join(', ')}\n`;
                            }
                        } else {
                             text += joined + '\n';
                        }
                    }
                    document.getElementById('inputAvoid').value = text;
                }
                
                showStatus("엑셀 데이터 불러오기 완료!", "success");
                input.value = "";
            };
            reader.readAsArrayBuffer(file);
        }

        function runAnalysis() {
            allStudents.clear();
            allTeams = [];
            finalClasses = [];
            
            const numClasses = parseInt(document.getElementById('classCount').value) || 10;
            const minPerClass = parseInt(document.getElementById('minPerClass').value) || 0;
            const maxPerClass = parseInt(document.getElementById('maxPerClass').value) || 999;
            const scoreTolerance = parseFloat(document.getElementById('scoreTolerance').value) || 5.0;
            const useRandom = document.getElementById('useRandom').checked;
            const splitRightGroup = document.getElementById('avoidSplitRight').checked;
            
            const rawMaster = document.getElementById('inputMaster').value;
            const rawFixed = document.getElementById('inputFixed').value;
            const rawTogether = document.getElementById('inputTogether').value;
            const rawSeparate = document.getElementById('inputSeparate').value;
            const rawAvoid = document.getElementById('inputAvoid').value;

            const masterLines = rawMaster.split('\n');
            if (masterLines.length < 2 && !rawMaster.trim()) {
                showStatus("전교생 명단을 입력해주세요.", 'error');
                return;
            }

            masterLines.forEach(line => {
                if (!line.trim()) return;
                const parts = line.split('/');
                if (parts.length < 5) return; // Expect 5 parts now
                
                const draftClass = parts[0].trim();
                const currentClass = parts[1].trim();
                const name = parts[2].trim();
                const gender = parts[3].trim();
                const score = parts[4] ? parts[4].trim() : "0";

                if (!allStudents.has(name)) {
                    allStudents.set(name, new Student(draftClass, currentClass, name, gender, score));
                }
            });

            const totalStudents = allStudents.size;
            if (totalStudents > maxPerClass * numClasses) {
                showStatus(`오류: 전교생(${totalStudents}명)이 최대수용인원(${maxPerClass*numClasses}명)을 초과합니다.`, 'error');
                return;
            }
            if (totalStudents < minPerClass * numClasses) {
                showStatus(`오류: 전교생(${totalStudents}명)이 최소인원합계(${minPerClass*numClasses}명)보다 적습니다.`, 'error');
                return;
            }

            // Teams
            let tempTeamMap = new Map();
            let nextTeamId = 0;
            const getTeamId = (name) => {
                if (!allStudents.has(name)) return null; 
                if (!tempTeamMap.has(name)) tempTeamMap.set(name, nextTeamId++);
                return tempTeamMap.get(name);
            }

            let teamMerges = new Map();
            for (let i = 0; i < allStudents.size * 2; i++) teamMerges.set(i, i);
            const findRoot = (id) => {
                if (teamMerges.get(id) === id) return id;
                const root = findRoot(teamMerges.get(id));
                teamMerges.set(id, root);
                return root;
            }
            const unionTeams = (id1, id2) => {
                const r1 = findRoot(id1), r2 = findRoot(id2);
                if (r1 !== r2) teamMerges.set(r2, r1);
            }

            rawTogether.split('\n').forEach(line => {
                const names = parseNames(line);
                if (names.length < 2) return;
                const validIds = names.map(n => getTeamId(n)).filter(id => id !== null);
                for (let i = 0; i < validIds.length - 1; i++) unionTeams(validIds[i], validIds[i+1]);
            });

            let rootToTeamObj = new Map();
            allStudents.forEach((student, name) => {
                const tid = getTeamId(name);
                const rootId = findRoot(tid);
                if (!rootToTeamObj.has(rootId)) rootToTeamObj.set(rootId, new Team(rootId));
                rootToTeamObj.get(rootId).addMember(student);
            });
            allTeams = Array.from(rootToTeamObj.values());
            allTeams.forEach(t => t.resolveDraftClass());

            rawFixed.split('\n').forEach(line => {
                if (!line.includes('/')) return;
                const [name, cNum] = line.split('/').map(s=>s.trim());
                const student = allStudents.get(name);
                if (student) {
                    const team = rootToTeamObj.get(findRoot(student.teamId));
                    team.fixedClass = parseInt(cNum);
                    team.members.forEach(m => m.fixedClass = parseInt(cNum));
                }
            });

            let teamConstraints = new Map();
            allTeams.forEach(t => teamConstraints.set(t, new Set()));
            
            const addConstraint = (n1, n2) => {
                const t1 = rootToTeamObj.get(findRoot(getTeamId(n1)));
                const t2 = rootToTeamObj.get(findRoot(getTeamId(n2)));
                if (t1 && t2 && t1 !== t2) { t1.constraints.add(t2.id); t2.constraints.add(t1.id); }
            };
            const addSoftConstraint = (n1, n2) => {
                const t1 = rootToTeamObj.get(findRoot(getTeamId(n1)));
                const t2 = rootToTeamObj.get(findRoot(getTeamId(n2)));
                if (t1 && t2 && t1 !== t2) { t1.softConstraints.add(t2.id); t2.softConstraints.add(t1.id); }
            };

            try {
                // Separate
                rawSeparate.split('\n').forEach(line => {
                    const names = parseNames(line);
                    for(let i=0; i<names.length; i++) for(let j=i+1; j<names.length; j++) addConstraint(names[i], names[j]);
                });
                
                // Avoid
                rawAvoid.split('\n').forEach(line => {
                    if(!line.includes('//')) return;
                    const parts = line.split('//');
                    const targets = parseNames(parts[0]);
                    const avoids = parseNames(parts[1]);
                    
                    // Left vs Right: Always Hard
                    targets.forEach(t => avoids.forEach(a => addConstraint(t, a)));
                    
                    // Right vs Right: Soft IF CHECKED
                    if (splitRightGroup) {
                        for(let i=0; i<avoids.length; i++) {
                            for(let j=i+1; j<avoids.length; j++) {
                                addSoftConstraint(avoids[i], avoids[j]);
                            }
                        }
                    }
                });
            } catch(e) {}

            // Shuffle
            if (useRandom) {
                for (let i = allTeams.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allTeams[i], allTeams[j]] = [allTeams[j], allTeams[i]];
                }
            }

            // Sort
            allTeams.sort((a, b) => {
                if (a.fixedClass && !b.fixedClass) return -1;
                if (!a.fixedClass && b.fixedClass) return 1;
                return b.constraints.size - a.constraints.size || b.totalScore - a.totalScore;
            });

            let classes = Array.from({length: numClasses}, (_, i) => ({
                id: i+1, teams: [], students: [], totalScore: 0, gender: { M: 0, F: 0 }, count: 0
            }));
            
            let globalM = 0, globalF = 0, totalGlobalScore = 0;
            allStudents.forEach(s => { 
                s.gender === 'M' ? globalM++ : globalF++; 
                totalGlobalScore += s.score;
            });
            const globalAvgScore = totalGlobalScore / totalStudents;

            let studentsRemaining = allStudents.size;
            let movedCount = 0;
            let failedTeams = [];

            allTeams.forEach(team => {
                const futureRemaining = studentsRemaining - team.count;

                let validClasses = classes.filter(c => {
                    if (c.teams.some(existing => team.constraints.has(existing.id))) return false;
                    if (c.count + team.count > maxPerClass) return false;
                    
                    // Starvation Check
                    let deficitSum = 0;
                    classes.forEach(oc => {
                        let ocCount = oc.count;
                        if (oc === c) ocCount += team.count;
                        deficitSum += Math.max(0, minPerClass - ocCount);
                    });
                    if (futureRemaining < deficitSum) return false;

                    return true;
                });

                if (validClasses.length === 0) {
                    failedTeams.push(team);
                    studentsRemaining -= team.count; 
                    return;
                }

                let bestClass = null;
                if (team.fixedClass) {
                    bestClass = validClasses.find(c => c.id === team.fixedClass);
                    if (!bestClass) { failedTeams.push(team); studentsRemaining -= team.count; return; }
                } else {
                    // *** HYBRID LOGIC: Water Filling + Tolerance Check ***
                    
                    const candidates = [...validClasses];
                    candidates.sort((c1, c2) => {
                        // 1. Gender Balance (Absolute priority for Water Filling)
                        const mDiff = team.genderCount.M;
                        const fDiff = team.genderCount.F;
                        let c1Load = (mDiff >= fDiff) ? c1.gender.M : c1.gender.F;
                        let c2Load = (mDiff >= fDiff) ? c2.gender.M : c2.gender.F;
                        if (mDiff === 0 && fDiff === 0) { c1Load = c1.count; c2Load = c2.count; }

                        if (c1Load !== c2Load) return c1Load - c2Load;
                        
                        // 2. Total Count Secondary
                        if (c1.count !== c2.count) return c1.count - c2.count;

                        // 3. Soft Constraints (Tertiary: Priority over Original Class)
                        let p1 = 0, p2 = 0;
                        c1.teams.forEach(t => { if(team.softConstraints.has(t.id)) p1++; });
                        c2.teams.forEach(t => { if(team.softConstraints.has(t.id)) p2++; });
                        if (p1 !== p2) return p1 - p2; // Fewer violations is better
                        
                        // 4. Randomness (if enabled, and close call)
                        if (useRandom && Math.abs(c1.totalScore - c2.totalScore) < 1) {
                            return Math.random() - 0.5;
                        }

                        // 5. Score
                        return c1.totalScore - c2.totalScore;
                    });
                    
                    const bestBalanceClass = candidates[0];
                    
                    // Smart Retention Check
                    let originalCandidate = null;
                    if (team.draftClass) { // Check draftClass instead of originalClass
                        originalCandidate = validClasses.find(c => c.id === team.draftClass);
                    }

                    if (originalCandidate) {
                        const mDiff = team.genderCount.M;
                        const fDiff = team.genderCount.F;
                        let bestLoad = (mDiff >= fDiff) ? bestBalanceClass.gender.M : bestBalanceClass.gender.F;
                        let origLoad = (mDiff >= fDiff) ? originalCandidate.gender.M : originalCandidate.gender.F;
                        if (mDiff === 0 && fDiff === 0) { bestLoad = bestBalanceClass.count; origLoad = originalCandidate.count; }

                        const genderImbalance = origLoad - bestLoad; 
                        const countImbalance = originalCandidate.count - bestBalanceClass.count;

                        const currentSum = originalCandidate.totalScore + team.totalScore;
                        const currentCount = originalCandidate.count + team.count;
                        const projectedAvg = currentSum / currentCount;
                        const scoreDeviation = Math.abs(projectedAvg - globalAvgScore);

                        // Check soft constraint violation in original class
                        let softViolation = false;
                        originalCandidate.teams.forEach(existing => { if(team.softConstraints.has(existing.id)) softViolation = true; });

                        // Tolerance: Allow +1 imbalance, score deviation within tolerance
                        if (genderImbalance <= 1 && countImbalance <= 1 && scoreDeviation <= scoreTolerance && !softViolation) {
                            bestClass = originalCandidate;
                        } else {
                            bestClass = bestBalanceClass;
                        }
                    } else {
                        bestClass = bestBalanceClass;
                    }
                }

                bestClass.teams.push(team);
                bestClass.students.push(...team.members);
                bestClass.totalScore += team.totalScore;
                bestClass.gender.M += team.genderCount.M;
                bestClass.gender.F += team.genderCount.F;
                bestClass.count += team.count;

                team.members.forEach(m => {
                    m.finalClass = bestClass.id;
                    if (m.draftClass && m.draftClass !== bestClass.id) movedCount++;
                });
                
                studentsRemaining -= team.count;
            });

            finalClasses = classes; // Store for export

            if (failedTeams.length > 0) {
                const names = failedTeams.map(t => t.members[0].name).slice(0, 3).join(', ');
                showStatus(`실패: ${names} 외 ${failedTeams.length-1}팀. 조건/인원을 확인하세요.`, 'error');
                return;
            }

            renderDashboard(classes, allStudents.size, movedCount, minPerClass, maxPerClass);
            showStatus(`최적화 완료! 총 ${movedCount}명 이동 (허용오차 내 원반 유지)`, 'success');
        }

        function renderDashboard(classes, total, moved, min, max) {
            const container = document.getElementById('resultContainer');
            const globalStats = document.getElementById('globalStats');
            
            container.innerHTML = '';
            globalStats.classList.remove('hidden');

            let tS = 0, tM = 0, tF = 0;
            classes.forEach(c => { tS+=c.totalScore; tM+=c.gender.M; tF+=c.gender.F; });
            const globalAvg = (tS/total).toFixed(1);
            
            globalStats.innerHTML = `
                <div class="flex items-center gap-2"><span class="font-bold text-slate-600">이동</span><span class="bg-indigo-100 text-indigo-700 px-2 py-0.5 rounded font-bold">${moved}</span></div>
                <div class="w-px h-4 bg-slate-300"></div>
                <div class="flex items-center gap-2"><span class="font-bold text-slate-600">성비</span><span class="text-blue-600 font-bold"><i class="fas fa-mars"></i> ${tM}</span><span class="text-pink-600 font-bold"><i class="fas fa-venus"></i> ${tF}</span></div>
                <div class="w-px h-4 bg-slate-300"></div>
                <div class="flex items-center gap-2"><span class="font-bold text-slate-600">전체평균</span><span class="text-slate-800 font-bold">${globalAvg}</span></div>
            `;

            const grid = document.createElement('div');
            grid.className = "grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6";

            classes.forEach(c => {
                const avg = c.count > 0 ? (c.totalScore/c.count).toFixed(1) : 0;
                const diff = (avg - globalAvg).toFixed(1);
                c.students.sort((a,b) => (a.originalClass!==c.id) === (b.originalClass!==c.id) ? b.score-a.score : (a.originalClass!==c.id ? -1 : 1));
                
                let countColor = 'text-slate-500';
                if (c.count < min || c.count > max) countColor = 'text-red-600 font-bold';
                else if (c.count === min || c.count === max) countColor = 'text-indigo-600 font-bold';

                const card = document.createElement('div');
                card.className = "class-card bg-white rounded-xl shadow border border-slate-200 p-4 flex flex-col transition hover:shadow-md";
                card.innerHTML = `
                    <div class="flex justify-between items-start mb-3 border-b border-slate-100 pb-2">
                        <div>
                            <h3 class="font-bold text-lg text-slate-800 flex items-center">${c.id}반 <span class="text-sm font-normal ml-2 ${countColor}">(${c.count}명)</span></h3>
                            <div class="text-xs space-x-2 mt-1"><span class="text-blue-600"><i class="fas fa-mars"></i> ${c.gender.M}</span><span class="text-pink-600"><i class="fas fa-venus"></i> ${c.gender.F}</span></div>
                        </div>
                        <div class="text-right">
                            <div class="text-sm font-bold text-indigo-700">Avg: ${avg}</div>
                            <div class="text-[0.65rem] text-slate-400">(${diff > 0 ? '+'+diff : diff})</div>
                        </div>
                    </div>
                    <div class="flex-grow flex flex-wrap content-start">${c.students.map(s => {
                        let badges = '';
                        if(s.draftClass && s.draftClass !== c.id) badges += `<span class="move-badge">${s.draftClass}→${c.id}</span>`;
                        if(s.fixedClass) badges += '<i class="fas fa-thumbtack fixed-pin mr-1"></i>';
                        return `<span class="student-chip ${s.gender==='M'?'chip-male':'chip-female'}" onclick="highlight('${s.name}')" data-name="${s.name}">${badges} ${s.name} <span class="text-[0.65rem] opacity-60 ml-1">${s.score}</span></span>`;
                    }).join('')}</div>
                `;
                grid.appendChild(card);
            });
            container.appendChild(grid);
        }

        function highlight(name) {
            document.querySelectorAll('.student-chip').forEach(el => el.classList.remove('highlight-target', 'highlight-friend', 'highlight-enemy', 'dimmed'));
            const student = allStudents.get(name);
            if (!student) return;
            const team = allTeams.find(t => t.members.some(m => m.name === name));
            if (!team) return;
            
            document.querySelectorAll('.student-chip').forEach(el => el.classList.add('dimmed'));
            team.members.forEach(m => document.querySelector(`.student-chip[data-name="${m.name}"]`)?.classList.replace('dimmed', m.name===name?'highlight-target':'highlight-friend'));
            team.constraints.forEach(eid => {
                const et = allTeams.find(t => t.id === eid);
                if(et) et.members.forEach(m => document.querySelector(`.student-chip[data-name="${m.name}"]`)?.classList.replace('dimmed', 'highlight-enemy'));
            });
        }
        
        document.addEventListener('click', e => { if(!e.target.closest('.student-chip')) document.querySelectorAll('.student-chip').forEach(el => el.classList.remove('highlight-target', 'highlight-friend', 'highlight-enemy', 'dimmed')); });

        // --- Export Function ---
        function exportToExcel() {
            if (finalClasses.length === 0) {
                alert("먼저 [편성 실행]을 눌러 반 편성을 완료해주세요.");
                return;
            }

            const wb = XLSX.utils.book_new();

            // 1. Sheet: 진급반명부 (Sorted by New Class) - Renamed from 반편성명부
            let rosterNewClass = [];
            finalClasses.forEach(c => {
                c.students.forEach(s => {
                    let note = [];
                    if (s.draftClass && s.draftClass !== c.id) note.push(`이동(${s.draftClass}→${c.id})`);
                    if (s.fixedClass) note.push("고정");
                    
                    rosterNewClass.push({
                        "진급반": c.id,
                        "이름": s.name,
                        "성별": s.gender === 'M' ? '남' : '여',
                        "점수": s.score,
                        "진급예정반": s.draftClass || "",
                        "현재반": s.currentClass || "",
                        "비고": note.join(", ")
                    });
                });
            });
            // Sort by New Class then Name
            rosterNewClass.sort((a,b) => (a.진급반 - b.진급반) || (a.이름.localeCompare(b.이름)));
            const wsRosterNew = XLSX.utils.json_to_sheet(rosterNewClass);
            XLSX.utils.book_append_sheet(wb, wsRosterNew, "진급반명부");

            // 2. Sheet: 현재반명부 (Sorted by Original Class) - NEW
            let rosterOldClass = [];
            finalClasses.forEach(c => {
                c.students.forEach(s => {
                    let note = [];
                    if (s.draftClass && s.draftClass !== c.id) note.push("반이동");
                    if (s.fixedClass) note.push("고정");

                    rosterOldClass.push({
                        "현재반": s.currentClass || "(미입력)",
                        "이름": s.name,
                        "성별": s.gender === 'M' ? '남' : '여',
                        "점수": s.score,
                        "진급반": c.id,
                        "비고": note.join(", ")
                    });
                });
            });
            // Sort by Original Class then Name
            rosterOldClass.sort((a,b) => {
                const classA = parseInt(a.현재반) || 9999;
                const classB = parseInt(b.현재반) || 9999;
                return (classA - classB) || (a.이름.localeCompare(b.이름));
            });
            const wsRosterOld = XLSX.utils.json_to_sheet(rosterOldClass);
            XLSX.utils.book_append_sheet(wb, wsRosterOld, "현재반명부");

            // 3. Sheet: Stats (통계)
            let statsData = [];
            let totalS = 0, totalM = 0, totalF = 0, totalCount = 0;
            finalClasses.forEach(c => {
                const avg = c.count > 0 ? (c.totalScore / c.count).toFixed(2) : 0;
                totalS += c.totalScore; totalM += c.gender.M; totalF += c.gender.F; totalCount += c.count;
                statsData.push({
                    "반": c.id,
                    "총원": c.count,
                    "남": c.gender.M,
                    "여": c.gender.F,
                    "평균점수": avg
                });
            });
            const globalAvg = (totalS / totalCount).toFixed(2);
            statsData.forEach(d => d["평균편차"] = (d.평균점수 - globalAvg).toFixed(2));
            const wsStats = XLSX.utils.json_to_sheet(statsData);
            XLSX.utils.book_append_sheet(wb, wsStats, "학급통계");

            // 4. Sheet: Verification (조건검증 - Multi-row Style)
            let verifyData = [];
            
            // Helper to get formatted name trace
            const getTrace = (name) => {
                const s = allStudents.get(name);
                if (!s) return `${name}(?)`;
                return `${name}(${s.draftClass}→${s.finalClass})`;
            };

            // Fixed
            document.getElementById('inputFixed').value.split('\n').forEach(line => {
                if(!line.includes('/')) return;
                const [name, cNumStr] = line.split('/').map(s=>s.trim());
                const targetClass = parseInt(cNumStr);
                const student = allStudents.get(name);
                if(student) {
                    const success = (student.finalClass === targetClass);
                    verifyData.push({ "구분": "반고정", "입력": `${name}(${targetClass}반)`, "결과": success ? "O" : "X", "상세내용": getTrace(name) });
                }
            });

            // Together
            document.getElementById('inputTogether').value.split('\n').forEach(line => {
                const names = parseNames(line);
                if(names.length < 2) return;
                const firstClass = allStudents.get(names[0])?.finalClass;
                const allSame = names.every(n => allStudents.get(n)?.finalClass === firstClass);
                
                verifyData.push({ "구분": "단짝", "입력": line, "결과": allSame ? "O" : "X", "상세내용": getTrace(names[0]) });
                for(let i=1; i<names.length; i++) {
                    verifyData.push({ "구분": "", "입력": "", "결과": "", "상세내용": getTrace(names[i]) });
                }
            });

            // Separate
            document.getElementById('inputSeparate').value.split('\n').forEach(line => {
                const names = parseNames(line);
                if(names.length < 2) return;
                const classes = names.map(n => allStudents.get(n)?.finalClass);
                const unique = new Set(classes).size === classes.length;
                
                verifyData.push({ "구분": "분리", "입력": line, "결과": unique ? "O" : "X", "상세내용": getTrace(names[0]) });
                for(let i=1; i<names.length; i++) {
                    verifyData.push({ "구분": "", "입력": "", "결과": "", "상세내용": getTrace(names[i]) });
                }
            });

            // Avoid
            document.getElementById('inputAvoid').value.split('\n').forEach(line => {
                if(!line.includes('//')) return;
                const [targets, avoids] = line.split('//').map(s => parseNames(s));
                const tClasses = targets.map(n => allStudents.get(n)?.finalClass);
                const aClasses = avoids.map(n => allStudents.get(n)?.finalClass);
                const conflict = tClasses.some(tc => aClasses.includes(tc));
                
                verifyData.push({ "구분": "피하기", "입력": line, "결과": !conflict ? "O" : "X", "상세내용": `[기준] ${getTrace(targets[0])}` });
                for(let i=1; i<targets.length; i++) verifyData.push({ "구분": "", "입력": "", "결과": "", "상세내용": `[기준] ${getTrace(targets[i])}` });
                for(let i=0; i<avoids.length; i++) verifyData.push({ "구분": "", "입력": "", "결과": "", "상세내용": `[회피] ${getTrace(avoids[i])}` });
            });

            const wsVerify = XLSX.utils.json_to_sheet(verifyData);
            XLSX.utils.book_append_sheet(wb, wsVerify, "조건검증");

            // 5. Sheet: Summary (반편성요약 - Vertical Style)
            let summaryData = [];
            
            // Header: Classes
            let headerRow = [];
            finalClasses.forEach(c => headerRow.push(c.id + "반"));
            summaryData.push(headerRow);

            // Row: "남학생" Label
            summaryData.push(new Array(finalClasses.length).fill("남학생"));

            // Find max rows for males and females
            let maxMale = 0, maxFemale = 0;
            finalClasses.forEach(c => {
                const m = c.students.filter(s => s.gender === 'M').length;
                const f = c.students.filter(s => s.gender === 'F').length;
                if (m > maxMale) maxMale = m;
                if (f > maxFemale) maxFemale = f;
            });

            // Male Rows
            for(let i=0; i<maxMale; i++) {
                let row = [];
                finalClasses.forEach(c => {
                    let males = c.students.filter(s => s.gender === 'M').sort((a,b) => a.name.localeCompare(b.name));
                    row.push(males[i] ? males[i].name : "");
                });
                summaryData.push(row);
            }

            // Separator
            summaryData.push([]); 

            // Row: "여학생" Label
            summaryData.push(new Array(finalClasses.length).fill("여학생"));

            // Female Rows
            for(let i=0; i<maxFemale; i++) {
                let row = [];
                finalClasses.forEach(c => {
                    let females = c.students.filter(s => s.gender === 'F').sort((a,b) => a.name.localeCompare(b.name));
                    row.push(females[i] ? females[i].name : "");
                });
                summaryData.push(row);
            }

            const wsSummary = XLSX.utils.aoa_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(wb, wsSummary, "반편성요약");

            XLSX.writeFile(wb, "반편성결과.xlsx");
        }
    </script>
</body>
</html>
